/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function U(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function j(...e){const r=o=>o,n=(o,f)=>d=>o(f(d)),i=e.map(o=>o.encode).reduceRight(n,r),t=e.map(o=>o.decode).reduce(n,r);return{encode:i,decode:t}}function k(e){return{encode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return r.map(n=>{if(n<0||n>=e.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);return e[n]})},decode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("alphabet.decode input should be array of strings");return r.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const i=e.indexOf(n);if(i===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);return i})}}}function B(e=""){if(typeof e!="string")throw new Error("join separator should be string");return{encode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of r)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return r.join(e)},decode:r=>{if(typeof r!="string")throw new Error("join.decode input should be string");return r.split(e)}}}const m=(e,r)=>r?m(r,e%r):e,p=(e,r)=>e+(r-m(e,r));function g(e,r,n,i){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(r<=0||r>32)throw new Error(`convertRadix2: wrong from=${r}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(p(r,n)>32)throw new Error(`convertRadix2: carry overflow from=${r} to=${n} carryBits=${p(r,n)}`);let t=0,o=0;const f=2**n-1,d=[];for(const u of e){if(u>=2**r)throw new Error(`convertRadix2: invalid data word=${u} from=${r}`);if(t=t<<r|u,o+r>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${r}`);for(o+=r;o>=n;o-=n)d.push((t>>o-n&f)>>>0);t&=2**o-1}if(t=t<<n-o&f,!i&&o>=r)throw new Error("Excess padding");if(!i&&t)throw new Error(`Non-zero padding: ${t}`);return i&&o>0&&d.push(t>>>0),d}function L(e,r=!1){if(e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(p(8,e)>32||p(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!U(n))throw new Error("radix2.encode input should be Uint8Array");return g(Array.from(n),8,e,!r)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of numbers");return Uint8Array.from(g(n,e,8,r))}}}function x(e){if(typeof e!="function")throw new Error("unsafeWrapper fn should be function");return function(...r){try{return e.apply(null,r)}catch{}}}const E=j(k("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),B("")),A=[996825010,642813549,513874426,1027748829,705979059];function y(e){const r=e>>25;let n=(e&33554431)<<5;for(let i=0;i<A.length;i++)(r>>i&1)===1&&(n^=A[i]);return n}function v(e,r,n=1){const i=e.length;let t=1;for(let o=0;o<i;o++){const f=e.charCodeAt(o);if(f<33||f>126)throw new Error(`Invalid prefix (${e})`);t=y(t)^f>>5}t=y(t);for(let o=0;o<i;o++)t=y(t)^e.charCodeAt(o)&31;for(let o of r)t=y(t)^o;for(let o=0;o<6;o++)t=y(t);return t^=n,E.encode(g([t%2**30],30,5,!1))}function O(e){const r=e==="bech32"?1:734539939,n=L(5),i=n.decode,t=n.encode,o=x(i);function f(c,a,s=90){if(typeof c!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof c}`);if(a instanceof Uint8Array&&(a=Array.from(a)),!Array.isArray(a)||a.length&&typeof a[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof a}`);if(c.length===0)throw new TypeError(`Invalid prefix length ${c.length}`);const h=c.length+7+a.length;if(s!==!1&&h>s)throw new TypeError(`Length ${h} exceeds limit ${s}`);const w=c.toLowerCase(),l=v(w,a,r);return`${w}1${E.encode(a)}${l}`}function d(c,a=90){if(typeof c!="string")throw new Error(`bech32.decode input should be string, not ${typeof c}`);if(c.length<8||a!==!1&&c.length>a)throw new TypeError(`Wrong string length: ${c.length} (${c}). Expected (8..${a})`);const s=c.toLowerCase();if(c!==s&&c!==c.toUpperCase())throw new Error("String must be lowercase or uppercase");const h=s.lastIndexOf("1");if(h===0||h===-1)throw new Error('Letter "1" must be present between prefix and data only');const w=s.slice(0,h),l=s.slice(h+1);if(l.length<6)throw new Error("Data must be at least 6 characters long");const b=E.decode(l).slice(0,-6),$=v(w,b,r);if(!l.endsWith($))throw new Error(`Invalid checksum in ${c}: expected "${$}"`);return{prefix:w,words:b}}const u=x(d);function R(c){const{prefix:a,words:s}=d(c,!1);return{prefix:a,words:s,bytes:i(s)}}function C(c,a){return f(c,t(a))}return{encode:f,decode:d,encodeFromBytes:C,decodeToBytes:R,decodeUnsafe:u,fromWords:i,fromWordsUnsafe:o,toWords:t}}const T=O("bech32");export{T as b};
