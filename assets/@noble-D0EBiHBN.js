function jt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function pe(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function tn(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function et(t,...e){if(!tn(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const M=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),en=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!en)throw new Error("Non little-endian hardware is not supported");function nn(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function gr(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const rn=(t,e)=>(Object.assign(e,t),e),ft=16,on=283;function re(t){return t<<1^on&-(t>>7)}function mt(t,e){let n=0;for(;e>0;e>>=1)n^=t&-(e&1),t=re(t);return n}const Gt=(()=>{let t=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=re(r))t[n]=r;const e=new Uint8Array(256);e[0]=99;for(let n=0;n<255;n++){let r=t[255-n];r|=r<<8,e[t[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return e})(),sn=Gt.map((t,e)=>Gt.indexOf(e)),cn=t=>t<<24|t>>>8,Kt=t=>t<<8|t>>>24;function Te(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((a,u)=>e(t[u])),r=n.map(Kt),i=r.map(Kt),s=i.map(Kt),f=new Uint32Array(256*256),c=new Uint32Array(256*256),o=new Uint16Array(256*256);for(let a=0;a<256;a++)for(let u=0;u<256;u++){const d=a*256+u;f[d]=n[a]^r[u],c[d]=i[a]^s[u],o[d]=t[a]<<8|t[u]}return{sbox:t,sbox2:o,T0:n,T1:r,T2:i,T3:s,T01:f,T23:c}}const oe=Te(Gt,t=>mt(t,3)<<24|t<<16|t<<8|mt(t,2)),Oe=Te(sn,t=>mt(t,11)<<24|mt(t,13)<<16|mt(t,9)<<8|mt(t,14)),fn=(()=>{const t=new Uint8Array(16);for(let e=0,n=1;e<16;e++,n=re(n))t[e]=n;return t})();function Ne(t){et(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:n}=oe,r=M(t),i=r.length,s=c=>W(n,c,c,c,c),f=new Uint32Array(e+28);f.set(r);for(let c=i;c<f.length;c++){let o=f[c-1];c%i===0?o=s(cn(o))^fn[c/i-1]:i>6&&c%i===4&&(o=s(o)),f[c]=f[c-i]^o}return f}function ln(t){const e=Ne(t),n=e.slice(),r=e.length,{sbox2:i}=oe,{T0:s,T1:f,T2:c,T3:o}=Oe;for(let a=0;a<r;a+=4)for(let u=0;u<4;u++)n[a+u]=e[r-a-4+u];e.fill(0);for(let a=4;a<r-4;a++){const u=n[a],d=W(i,u,u,u,u);n[a]=s[d&255]^f[d>>>8&255]^c[d>>>16&255]^o[d>>>24]}return n}function ct(t,e,n,r,i,s){return t[n<<8&65280|r>>>8&255]^e[i>>>8&65280|s>>>24&255]}function W(t,e,n,r,i){return t[e&255|n&65280]|t[r>>>16&255|i>>>16&65280]<<16}function be(t,e,n,r,i){const{sbox2:s,T01:f,T23:c}=oe;let o=0;e^=t[o++],n^=t[o++],r^=t[o++],i^=t[o++];const a=t.length/4-2;for(let B=0;B<a;B++){const w=t[o++]^ct(f,c,e,n,r,i),l=t[o++]^ct(f,c,n,r,i,e),g=t[o++]^ct(f,c,r,i,e,n),x=t[o++]^ct(f,c,i,e,n,r);e=w,n=l,r=g,i=x}const u=t[o++]^W(s,e,n,r,i),d=t[o++]^W(s,n,r,i,e),h=t[o++]^W(s,r,i,e,n),p=t[o++]^W(s,i,e,n,r);return{s0:u,s1:d,s2:h,s3:p}}function an(t,e,n,r,i){const{sbox2:s,T01:f,T23:c}=Oe;let o=0;e^=t[o++],n^=t[o++],r^=t[o++],i^=t[o++];const a=t.length/4-2;for(let B=0;B<a;B++){const w=t[o++]^ct(f,c,e,i,r,n),l=t[o++]^ct(f,c,n,e,i,r),g=t[o++]^ct(f,c,r,n,e,i),x=t[o++]^ct(f,c,i,r,n,e);e=w,n=l,r=g,i=x}const u=t[o++]^W(s,e,i,r,n),d=t[o++]^W(s,n,e,i,r),h=t[o++]^W(s,r,n,e,i),p=t[o++]^W(s,i,r,n,e);return{s0:u,s1:d,s2:h,s3:p}}function qe(t,e){if(!e)return new Uint8Array(t);if(et(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function un(t){if(et(t),t.length%ft!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${ft}`)}function dn(t,e,n){let r=t.length;const i=r%ft;if(!e&&i!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const s=M(t);if(e){let o=ft-i;o||(o=ft),r=r+o}const f=qe(r,n),c=M(f);return{b:s,o:c,out:f}}function hn(t,e){if(!e)return t;const n=t.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=t[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const i=t.subarray(0,-r);for(let s=0;s<r;s++)if(t[n-s-1]!==r)throw new Error("aes/pcks5: wrong padding");return i}function gn(t){const e=new Uint8Array(16),n=M(e);e.set(t);const r=ft-t.length;for(let i=ft-r;i<ft;i++)e[i]=r;return n}const wr=rn({blockSize:16,nonceLength:16},function(e,n,r={}){et(e),et(n,16);const i=!r.disablePadding;return{encrypt:(s,f)=>{const c=Ne(e),{b:o,o:a,out:u}=dn(s,i,f),d=M(n);let h=d[0],p=d[1],B=d[2],w=d[3],l=0;for(;l+4<=o.length;)h^=o[l+0],p^=o[l+1],B^=o[l+2],w^=o[l+3],{s0:h,s1:p,s2:B,s3:w}=be(c,h,p,B,w),a[l++]=h,a[l++]=p,a[l++]=B,a[l++]=w;if(i){const g=gn(s.subarray(l*4));h^=g[0],p^=g[1],B^=g[2],w^=g[3],{s0:h,s1:p,s2:B,s3:w}=be(c,h,p,B,w),a[l++]=h,a[l++]=p,a[l++]=B,a[l++]=w}return c.fill(0),u},decrypt:(s,f)=>{un(s);const c=ln(e),o=M(n),a=qe(s.length,f),u=M(s),d=M(a);let h=o[0],p=o[1],B=o[2],w=o[3];for(let l=0;l+4<=u.length;){const g=h,x=p,_=B,$=w;h=u[l+0],p=u[l+1],B=u[l+2],w=u[l+3];const{s0:O,s1:v,s2:E,s3:A}=an(c,h,p,B,w);d[l++]=O^g,d[l++]=v^x,d[l++]=E^_,d[l++]=A^$}return c.fill(0),hn(a,i)}}}),He=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),wn=He("expand 16-byte k"),yn=He("expand 32-byte k"),pn=M(wn),Ce=M(yn);Ce.slice();function q(t,e){return t<<e|t>>>32-e}function Dt(t){return t.byteOffset%4===0}const Nt=64,bn=16,Re=2**32-1,me=new Uint32Array;function mn(t,e,n,r,i,s,f,c){const o=i.length,a=new Uint8Array(Nt),u=M(a),d=Dt(i)&&Dt(s),h=d?M(i):me,p=d?M(s):me;for(let B=0;B<o;f++){if(t(e,n,r,u,f,c),f>=Re)throw new Error("arx: counter overflow");const w=Math.min(Nt,o-B);if(d&&w===Nt){const l=B/4;if(B%4!==0)throw new Error("arx: invalid block position");for(let g=0,x;g<bn;g++)x=l+g,p[x]=h[x]^u[g];B+=Nt;continue}for(let l=0,g;l<w;l++)g=B+l,s[g]=i[g]^a[l];B+=w}}function xn(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:i,counterRight:s,rounds:f}=nn({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return jt(i),jt(f),pe(s),pe(n),(c,o,a,u,d=0)=>{et(c),et(o),et(a);const h=a.length;if(u||(u=new Uint8Array(h)),et(u),jt(d),d<0||d>=Re)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let B=c.length,w,l;if(B===32)w=c.slice(),p.push(w),l=Ce;else if(B===16&&n)w=new Uint8Array(32),w.set(c),w.set(c,16),l=pn,p.push(w);else throw new Error(`arx: invalid 32-byte key, got length=${B}`);Dt(o)||(o=o.slice(),p.push(o));const g=M(w);if(r){if(o.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(l,g,M(o.subarray(0,16)),g),o=o.subarray(16)}const x=16-i;if(x!==o.length)throw new Error(`arx: nonce must be ${x} or 16 bytes`);if(x!==12){const $=new Uint8Array(12);$.set(o,s?0:12-o.length),o=$,p.push(o)}const _=M(o);for(mn(t,l,g,_,a,u,d,f);p.length>0;)p.pop().fill(0);return u}}function En(t,e,n,r,i,s=20){let f=t[0],c=t[1],o=t[2],a=t[3],u=e[0],d=e[1],h=e[2],p=e[3],B=e[4],w=e[5],l=e[6],g=e[7],x=i,_=n[0],$=n[1],O=n[2],v=f,E=c,A=o,I=a,z=u,T=d,U=h,R=p,y=B,b=w,m=l,S=g,L=x,N=_,H=$,C=O;for(let Y=0;Y<s;Y+=2)v=v+z|0,L=q(L^v,16),y=y+L|0,z=q(z^y,12),v=v+z|0,L=q(L^v,8),y=y+L|0,z=q(z^y,7),E=E+T|0,N=q(N^E,16),b=b+N|0,T=q(T^b,12),E=E+T|0,N=q(N^E,8),b=b+N|0,T=q(T^b,7),A=A+U|0,H=q(H^A,16),m=m+H|0,U=q(U^m,12),A=A+U|0,H=q(H^A,8),m=m+H|0,U=q(U^m,7),I=I+R|0,C=q(C^I,16),S=S+C|0,R=q(R^S,12),I=I+R|0,C=q(C^I,8),S=S+C|0,R=q(R^S,7),v=v+T|0,C=q(C^v,16),m=m+C|0,T=q(T^m,12),v=v+T|0,C=q(C^v,8),m=m+C|0,T=q(T^m,7),E=E+U|0,L=q(L^E,16),S=S+L|0,U=q(U^S,12),E=E+U|0,L=q(L^E,8),S=S+L|0,U=q(U^S,7),A=A+R|0,N=q(N^A,16),y=y+N|0,R=q(R^y,12),A=A+R|0,N=q(N^A,8),y=y+N|0,R=q(R^y,7),I=I+z|0,H=q(H^I,16),b=b+H|0,z=q(z^b,12),I=I+z|0,H=q(H^I,8),b=b+H|0,z=q(z^b,7);let Z=0;r[Z++]=f+v|0,r[Z++]=c+E|0,r[Z++]=o+A|0,r[Z++]=a+I|0,r[Z++]=u+z|0,r[Z++]=d+T|0,r[Z++]=h+U|0,r[Z++]=p+R|0,r[Z++]=B+y|0,r[Z++]=w+b|0,r[Z++]=l+m|0,r[Z++]=g+S|0,r[Z++]=x+L|0,r[Z++]=_+N|0,r[Z++]=$+H|0,r[Z++]=O+C|0}const yr=xn(En,{counterRight:!1,counterLength:4,allowShortKeys:!1});function xe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function Bn(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function Ut(t,...e){if(!Bn(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function An(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");xe(t.outputLen),xe(t.blockLen)}function qt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function vn(t,e){Ut(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const bt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),D=(t,e)=>t<<32-e|t>>>e;new Uint8Array(new Uint32Array([287454020]).buffer)[0];const Sn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function pr(t){Ut(t);let e="";for(let n=0;n<t.length;n++)e+=Sn[t[n]];return e}const X={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Ee(t){if(t>=X._0&&t<=X._9)return t-X._0;if(t>=X._A&&t<=X._F)return t-(X._A-10);if(t>=X._a&&t<=X._f)return t-(X._a-10)}function br(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let i=0,s=0;i<n;i++,s+=2){const f=Ee(t.charCodeAt(s)),c=Ee(t.charCodeAt(s+1));if(f===void 0||c===void 0){const o=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=f*16+c}return r}function In(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function ie(t){return typeof t=="string"&&(t=In(t)),Ut(t),t}function _n(...t){let e=0;for(let r=0;r<t.length;r++){const i=t[r];Ut(i),e+=i.length}const n=new Uint8Array(e);for(let r=0,i=0;r<t.length;r++){const s=t[r];n.set(s,i),i+=s.length}return n}class ze{clone(){return this._cloneInto()}}function $n(t){const e=r=>t().update(ie(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Ze(t=32){if(bt&&typeof bt.getRandomValues=="function")return bt.getRandomValues(new Uint8Array(t));if(bt&&typeof bt.randomBytes=="function")return bt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function Un(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const i=BigInt(32),s=BigInt(4294967295),f=Number(n>>i&s),c=Number(n&s),o=r?4:0,a=r?0:4;t.setUint32(e+o,f,r),t.setUint32(e+a,c,r)}const Ln=(t,e,n)=>t&e^~t&n,Tn=(t,e,n)=>t&e^t&n^e&n;class On extends ze{constructor(e,n,r,i){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pt(this.buffer)}update(e){qt(this);const{view:n,buffer:r,blockLen:i}=this;e=ie(e);const s=e.length;for(let f=0;f<s;){const c=Math.min(i-this.pos,s-f);if(c===i){const o=Pt(e);for(;i<=s-f;f+=i)this.process(o,f);continue}r.set(e.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===i&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){qt(this),vn(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:i,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>i-f&&(this.process(r,0),f=0);for(let d=f;d<i;d++)n[d]=0;Un(r,i-8,BigInt(this.length*8),s),this.process(r,0);const c=Pt(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=o/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<a;d++)c.setUint32(4*d,u[d],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:i,finished:s,destroyed:f,pos:c}=this;return e.length=i,e.pos=c,e.finished=s,e.destroyed=f,i%n&&e.buffer.set(r),e}}const Nn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),st=new Uint32Array(64);class qn extends On{constructor(){super(64,32,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){const{A:e,B:n,C:r,D:i,E:s,F:f,G:c,H:o}=this;return[e,n,r,i,s,f,c,o]}set(e,n,r,i,s,f,c,o){this.A=e|0,this.B=n|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=f|0,this.G=c|0,this.H=o|0}process(e,n){for(let d=0;d<16;d++,n+=4)st[d]=e.getUint32(n,!1);for(let d=16;d<64;d++){const h=st[d-15],p=st[d-2],B=D(h,7)^D(h,18)^h>>>3,w=D(p,17)^D(p,19)^p>>>10;st[d]=w+st[d-7]+B+st[d-16]|0}let{A:r,B:i,C:s,D:f,E:c,F:o,G:a,H:u}=this;for(let d=0;d<64;d++){const h=D(c,6)^D(c,11)^D(c,25),p=u+h+Ln(c,o,a)+Nn[d]+st[d]|0,w=(D(r,2)^D(r,13)^D(r,22))+Tn(r,i,s)|0;u=a,a=o,o=c,c=f+p|0,f=s,s=i,i=r,r=p+w|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,f=f+this.D|0,c=c+this.E|0,o=o+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,i,s,f,c,o,a,u)}roundClean(){st.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Wt=$n(()=>new qn);class je extends ze{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,An(e);const r=ie(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return qt(this),this.iHash.update(e),this}digestInto(e){qt(this),Ut(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:i,destroyed:s,blockLen:f,outputLen:c}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=f,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ke=(t,e,n)=>new je(t,e).update(n).digest();Ke.create=(t,e)=>new je(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const se=BigInt(0),zt=BigInt(1),Hn=BigInt(2);function ht(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function Lt(t){if(!ht(t))throw new Error("Uint8Array expected")}function Bt(t,e){if(typeof e!="boolean")throw new Error(`${t} must be valid boolean, got "${e}".`)}const Cn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function At(t){Lt(t);let e="";for(let n=0;n<t.length;n++)e+=Cn[t[n]];return e}function xt(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function ce(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const Q={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Be(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q._A&&t<=Q._F)return t-(Q._A-10);if(t>=Q._a&&t<=Q._f)return t-(Q._a-10)}function vt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let i=0,s=0;i<n;i++,s+=2){const f=Be(t.charCodeAt(s)),c=Be(t.charCodeAt(s+1));if(f===void 0||c===void 0){const o=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=f*16+c}return r}function nt(t){return ce(At(t))}function fe(t){return Lt(t),ce(At(Uint8Array.from(t).reverse()))}function at(t,e){return vt(t.toString(16).padStart(e*2,"0"))}function le(t,e){return at(t,e).reverse()}function Rn(t){return vt(xt(t))}function k(t,e,n){let r;if(typeof e=="string")try{r=vt(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else if(ht(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const i=r.length;if(typeof n=="number"&&i!==n)throw new Error(`${t} expected ${n} bytes, got ${i}`);return r}function gt(...t){let e=0;for(let r=0;r<t.length;r++){const i=t[r];Lt(i),e+=i.length}const n=new Uint8Array(e);for(let r=0,i=0;r<t.length;r++){const s=t[r];n.set(s,i),i+=s.length}return n}function zn(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function Zn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}const Vt=t=>typeof t=="bigint"&&se<=t;function St(t,e,n){return Vt(t)&&Vt(e)&&Vt(n)&&e<=t&&t<n}function lt(t,e,n,r){if(!St(e,n,r))throw new Error(`expected valid ${t}: ${n} <= n < ${r}, got ${typeof e} ${e}`)}function Pe(t){let e;for(e=0;t>se;t>>=zt,e+=1);return e}function jn(t,e){return t>>BigInt(e)&zt}function Kn(t,e,n){return t|(n?zt:se)<<BigInt(e)}const ae=t=>(Hn<<BigInt(t-1))-zt,kt=t=>new Uint8Array(t),Ae=t=>Uint8Array.from(t);function Ve(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=kt(t),i=kt(t),s=0;const f=()=>{r.fill(1),i.fill(0),s=0},c=(...d)=>n(i,r,...d),o=(d=kt())=>{i=c(Ae([0]),d),r=c(),d.length!==0&&(i=c(Ae([1]),d),r=c())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<e;){r=c();const p=r.slice();h.push(p),d+=r.length}return gt(...h)};return(d,h)=>{f(),o(d);let p;for(;!(p=h(a()));)o();return f(),p}}const Pn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||ht(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Tt(t,e,n={}){const r=(i,s,f)=>{const c=Pn[s];if(typeof c!="function")throw new Error(`Invalid validator "${s}", expected function`);const o=t[i];if(!(f&&o===void 0)&&!c(o,t))throw new Error(`Invalid param ${String(i)}=${o} (${typeof o}), expected ${s}`)};for(const[i,s]of Object.entries(e))r(i,s,!1);for(const[i,s]of Object.entries(n))r(i,s,!0);return t}const Vn=()=>{throw new Error("not implemented")};function Xt(t){const e=new WeakMap;return(n,...r)=>{const i=e.get(n);if(i!==void 0)return i;const s=t(n,...r);return e.set(n,s),s}}const kn=Object.freeze(Object.defineProperty({__proto__:null,aInRange:lt,abool:Bt,abytes:Lt,bitGet:jn,bitLen:Pe,bitMask:ae,bitSet:Kn,bytesToHex:At,bytesToNumberBE:nt,bytesToNumberLE:fe,concatBytes:gt,createHmacDrbg:Ve,ensureBytes:k,equalBytes:zn,hexToBytes:vt,hexToNumber:ce,inRange:St,isBytes:ht,memoized:Xt,notImplemented:Vn,numberToBytesBE:at,numberToBytesLE:le,numberToHexUnpadded:xt,numberToVarBytesBE:Rn,utf8ToBytes:Zn,validateObject:Tt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt(0),j=BigInt(1),dt=BigInt(2),Mn=BigInt(3),Qt=BigInt(4),ve=BigInt(5),Se=BigInt(8);BigInt(9);BigInt(16);function V(t,e){const n=t%e;return n>=P?n:e+n}function Yn(t,e,n){if(n<=P||e<P)throw new Error("Expected power/modulo > 0");if(n===j)return P;let r=j;for(;e>P;)e&j&&(r=r*t%n),t=t*t%n,e>>=j;return r}function F(t,e,n){let r=t;for(;e-- >P;)r*=r,r%=n;return r}function Jt(t,e){if(t===P||e<=P)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=V(t,e),r=e,i=P,s=j;for(;n!==P;){const c=r/n,o=r%n,a=i-s*c;r=n,n=o,i=s,s=a}if(r!==j)throw new Error("invert: does not exist");return V(i,e)}function Fn(t){const e=(t-j)/dt;let n,r,i;for(n=t-j,r=0;n%dt===P;n/=dt,r++);for(i=dt;i<t&&Yn(i,e,t)!==t-j;i++);if(r===1){const f=(t+j)/Qt;return function(o,a){const u=o.pow(a,f);if(!o.eql(o.sqr(u),a))throw new Error("Cannot find square root");return u}}const s=(n+j)/dt;return function(c,o){if(c.pow(o,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,u=c.pow(c.mul(c.ONE,i),n),d=c.pow(o,s),h=c.pow(o,n);for(;!c.eql(h,c.ONE);){if(c.eql(h,c.ZERO))return c.ZERO;let p=1;for(let w=c.sqr(h);p<a&&!c.eql(w,c.ONE);p++)w=c.sqr(w);const B=c.pow(u,j<<BigInt(a-p-1));u=c.sqr(B),d=c.mul(d,B),h=c.mul(h,u),a=p}return d}}function Gn(t){if(t%Qt===Mn){const e=(t+j)/Qt;return function(r,i){const s=r.pow(i,e);if(!r.eql(r.sqr(s),i))throw new Error("Cannot find square root");return s}}if(t%Se===ve){const e=(t-ve)/Se;return function(r,i){const s=r.mul(i,dt),f=r.pow(s,e),c=r.mul(i,f),o=r.mul(r.mul(c,dt),f),a=r.mul(c,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),i))throw new Error("Cannot find square root");return a}}return Fn(t)}const Dn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Wn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Dn.reduce((r,i)=>(r[i]="function",r),e);return Tt(t,n)}function Xn(t,e,n){if(n<P)throw new Error("Expected power > 0");if(n===P)return t.ONE;if(n===j)return e;let r=t.ONE,i=e;for(;n>P;)n&j&&(r=t.mul(r,i)),i=t.sqr(i),n>>=j;return r}function Qn(t,e){const n=new Array(e.length),r=e.reduce((s,f,c)=>t.is0(f)?s:(n[c]=s,t.mul(s,f)),t.ONE),i=t.inv(r);return e.reduceRight((s,f,c)=>t.is0(f)?s:(n[c]=t.mul(s,n[c]),t.mul(s,f)),i),n}function ke(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Me(t,e,n=!1,r={}){if(t<=P)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:s}=ke(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Gn(t),c=Object.freeze({ORDER:t,BITS:i,BYTES:s,MASK:ae(i),ZERO:P,ONE:j,create:o=>V(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);return P<=o&&o<t},is0:o=>o===P,isOdd:o=>(o&j)===j,neg:o=>V(-o,t),eql:(o,a)=>o===a,sqr:o=>V(o*o,t),add:(o,a)=>V(o+a,t),sub:(o,a)=>V(o-a,t),mul:(o,a)=>V(o*a,t),pow:(o,a)=>Xn(c,o,a),div:(o,a)=>V(o*Jt(a,t),t),sqrN:o=>o*o,addN:(o,a)=>o+a,subN:(o,a)=>o-a,mulN:(o,a)=>o*a,inv:o=>Jt(o,t),sqrt:r.sqrt||(o=>f(c,o)),invertBatch:o=>Qn(c,o),cmov:(o,a,u)=>u?a:o,toBytes:o=>n?le(o,s):at(o,s),fromBytes:o=>{if(o.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${o.length}`);return n?fe(o):nt(o)}});return Object.freeze(c)}function Ye(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Fe(t){const e=Ye(t);return e+Math.ceil(e/2)}function Jn(t,e,n=!1){const r=t.length,i=Ye(e),s=Fe(e);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const f=n?nt(t):fe(t),c=V(f,e-j)+j;return n?le(c,i):at(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const tr=BigInt(0),Mt=BigInt(1),Yt=new WeakMap,Ie=new WeakMap;function er(t,e){const n=(s,f)=>{const c=f.negate();return s?c:f},r=s=>{if(!Number.isSafeInteger(s)||s<=0||s>e)throw new Error(`Wrong window size=${s}, should be [1..${e}]`)},i=s=>{r(s);const f=Math.ceil(e/s)+1,c=2**(s-1);return{windows:f,windowSize:c}};return{constTimeNegate:n,unsafeLadder(s,f){let c=t.ZERO,o=s;for(;f>tr;)f&Mt&&(c=c.add(o)),o=o.double(),f>>=Mt;return c},precomputeWindow(s,f){const{windows:c,windowSize:o}=i(f),a=[];let u=s,d=u;for(let h=0;h<c;h++){d=u,a.push(d);for(let p=1;p<o;p++)d=d.add(u),a.push(d);u=d.double()}return a},wNAF(s,f,c){const{windows:o,windowSize:a}=i(s);let u=t.ZERO,d=t.BASE;const h=BigInt(2**s-1),p=2**s,B=BigInt(s);for(let w=0;w<o;w++){const l=w*a;let g=Number(c&h);c>>=B,g>a&&(g-=p,c+=Mt);const x=l,_=l+Math.abs(g)-1,$=w%2!==0,O=g<0;g===0?d=d.add(n($,f[x])):u=u.add(n(O,f[_]))}return{p:u,f:d}},wNAFCached(s,f,c){const o=Ie.get(s)||1;let a=Yt.get(s);return a||(a=this.precomputeWindow(s,o),o!==1&&Yt.set(s,c(a))),this.wNAF(o,a,f)},setWindowSize(s,f){r(f),Ie.set(s,f),Yt.delete(s)}}}function nr(t,e,n,r){if(!Array.isArray(n)||!Array.isArray(r)||r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");r.forEach((u,d)=>{if(!e.isValid(u))throw new Error(`wrong scalar at index ${d}`)}),n.forEach((u,d)=>{if(!(u instanceof t))throw new Error(`wrong point at index ${d}`)});const i=Pe(BigInt(n.length)),s=i>12?i-3:i>4?i-2:i?2:1,f=(1<<s)-1,c=new Array(f+1).fill(t.ZERO),o=Math.floor((e.BITS-1)/s)*s;let a=t.ZERO;for(let u=o;u>=0;u-=s){c.fill(t.ZERO);for(let h=0;h<r.length;h++){const p=r[h],B=Number(p>>BigInt(u)&BigInt(f));c[B]=c[B].add(n[h])}let d=t.ZERO;for(let h=c.length-1,p=t.ZERO;h>0;h--)p=p.add(c[h]),d=d.add(p);if(a=a.add(d),u!==0)for(let h=0;h<s;h++)a=a.double()}return a}function Ge(t){return Wn(t.Fp),Tt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ke(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _e(t){t.lowS!==void 0&&Bt("lowS",t.lowS),t.prehash!==void 0&&Bt("prehash",t.prehash)}function rr(t){const e=Ge(t);Tt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:i}=e;if(n){if(!r.eql(i,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:or,hexToBytes:ir}=kn,J={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(t,e)=>{const{Err:n}=J;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,i=xt(r);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?xt(i.length/2|128):"";return`${xt(t)}${s}${i}${e}`},decode(t,e){const{Err:n}=J;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const i=e[r++],s=!!(i&128);let f=0;if(!s)f=i;else{const o=i&127;if(!o)throw new n("tlv.decode(long): indefinite length not supported");if(o>4)throw new n("tlv.decode(long): byte length is too big");const a=e.subarray(r,r+o);if(a.length!==o)throw new n("tlv.decode: length bytes not complete");if(a[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const u of a)f=f<<8|u;if(r+=o,f<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+f);if(c.length!==f)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+f)}}},_int:{encode(t){const{Err:e}=J;if(t<tt)throw new e("integer: negative integers are not allowed");let n=xt(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected assertion");return n},decode(t){const{Err:e}=J;if(t[0]&128)throw new e("Invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return or(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=J,i=typeof t=="string"?ir(t):t;Lt(i);const{v:s,l:f}=r.decode(48,i);if(f.length)throw new e("Invalid signature: left bytes after parsing");const{v:c,l:o}=r.decode(2,s),{v:a,l:u}=r.decode(2,o);if(u.length)throw new e("Invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(a)}},hexFromSig(t){const{_tlv:e,_int:n}=J,r=`${e.encode(2,n.encode(t.r))}${e.encode(2,n.encode(t.s))}`;return e.encode(48,r)}},tt=BigInt(0),K=BigInt(1);BigInt(2);const $e=BigInt(3);BigInt(4);function sr(t){const e=rr(t),{Fp:n}=e,r=Me(e.n,e.nBitLength),i=e.toBytes||((w,l,g)=>{const x=l.toAffine();return gt(Uint8Array.from([4]),n.toBytes(x.x),n.toBytes(x.y))}),s=e.fromBytes||(w=>{const l=w.subarray(1),g=n.fromBytes(l.subarray(0,n.BYTES)),x=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:g,y:x}});function f(w){const{a:l,b:g}=e,x=n.sqr(w),_=n.mul(x,w);return n.add(n.add(_,n.mul(w,l)),g)}if(!n.eql(n.sqr(e.Gy),f(e.Gx)))throw new Error("bad generator point: equation left != right");function c(w){return St(w,K,e.n)}function o(w){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:x,n:_}=e;if(l&&typeof w!="bigint"){if(ht(w)&&(w=At(w)),typeof w!="string"||!l.includes(w.length))throw new Error("Invalid key");w=w.padStart(g*2,"0")}let $;try{$=typeof w=="bigint"?w:nt(k("private key",w,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof w}`)}return x&&($=V($,_)),lt("private key",$,K,_),$}function a(w){if(!(w instanceof h))throw new Error("ProjectivePoint expected")}const u=Xt((w,l)=>{const{px:g,py:x,pz:_}=w;if(n.eql(_,n.ONE))return{x:g,y:x};const $=w.is0();l==null&&(l=$?n.ONE:n.inv(_));const O=n.mul(g,l),v=n.mul(x,l),E=n.mul(_,l);if($)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:O,y:v}}),d=Xt(w=>{if(w.is0()){if(e.allowInfinityPoint&&!n.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=w.toAffine();if(!n.isValid(l)||!n.isValid(g))throw new Error("bad point: x or y not FE");const x=n.sqr(g),_=f(l);if(!n.eql(x,_))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(l,g,x){if(this.px=l,this.py=g,this.pz=x,l==null||!n.isValid(l))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(x==null||!n.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(l){const{x:g,y:x}=l||{};if(!l||!n.isValid(g)||!n.isValid(x))throw new Error("invalid affine point");if(l instanceof h)throw new Error("projective point not allowed");const _=$=>n.eql($,n.ZERO);return _(g)&&_(x)?h.ZERO:new h(g,x,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=n.invertBatch(l.map(x=>x.pz));return l.map((x,_)=>x.toAffine(g[_])).map(h.fromAffine)}static fromHex(l){const g=h.fromAffine(s(k("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return h.BASE.multiply(o(l))}static msm(l,g){return nr(h,r,l,g)}_setWindowSize(l){B.setWindowSize(this,l)}assertValidity(){d(this)}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){a(l);const{px:g,py:x,pz:_}=this,{px:$,py:O,pz:v}=l,E=n.eql(n.mul(g,v),n.mul($,_)),A=n.eql(n.mul(x,v),n.mul(O,_));return E&&A}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:g}=e,x=n.mul(g,$e),{px:_,py:$,pz:O}=this;let v=n.ZERO,E=n.ZERO,A=n.ZERO,I=n.mul(_,_),z=n.mul($,$),T=n.mul(O,O),U=n.mul(_,$);return U=n.add(U,U),A=n.mul(_,O),A=n.add(A,A),v=n.mul(l,A),E=n.mul(x,T),E=n.add(v,E),v=n.sub(z,E),E=n.add(z,E),E=n.mul(v,E),v=n.mul(U,v),A=n.mul(x,A),T=n.mul(l,T),U=n.sub(I,T),U=n.mul(l,U),U=n.add(U,A),A=n.add(I,I),I=n.add(A,I),I=n.add(I,T),I=n.mul(I,U),E=n.add(E,I),T=n.mul($,O),T=n.add(T,T),I=n.mul(T,U),v=n.sub(v,I),A=n.mul(T,z),A=n.add(A,A),A=n.add(A,A),new h(v,E,A)}add(l){a(l);const{px:g,py:x,pz:_}=this,{px:$,py:O,pz:v}=l;let E=n.ZERO,A=n.ZERO,I=n.ZERO;const z=e.a,T=n.mul(e.b,$e);let U=n.mul(g,$),R=n.mul(x,O),y=n.mul(_,v),b=n.add(g,x),m=n.add($,O);b=n.mul(b,m),m=n.add(U,R),b=n.sub(b,m),m=n.add(g,_);let S=n.add($,v);return m=n.mul(m,S),S=n.add(U,y),m=n.sub(m,S),S=n.add(x,_),E=n.add(O,v),S=n.mul(S,E),E=n.add(R,y),S=n.sub(S,E),I=n.mul(z,m),E=n.mul(T,y),I=n.add(E,I),E=n.sub(R,I),I=n.add(R,I),A=n.mul(E,I),R=n.add(U,U),R=n.add(R,U),y=n.mul(z,y),m=n.mul(T,m),R=n.add(R,y),y=n.sub(U,y),y=n.mul(z,y),m=n.add(m,y),U=n.mul(R,m),A=n.add(A,U),U=n.mul(S,m),E=n.mul(b,E),E=n.sub(E,U),U=n.mul(b,R),I=n.mul(S,I),I=n.add(I,U),new h(E,A,I)}subtract(l){return this.add(l.negate())}is0(){return this.equals(h.ZERO)}wNAF(l){return B.wNAFCached(this,l,h.normalizeZ)}multiplyUnsafe(l){lt("scalar",l,tt,e.n);const g=h.ZERO;if(l===tt)return g;if(l===K)return this;const{endo:x}=e;if(!x)return B.unsafeLadder(this,l);let{k1neg:_,k1:$,k2neg:O,k2:v}=x.splitScalar(l),E=g,A=g,I=this;for(;$>tt||v>tt;)$&K&&(E=E.add(I)),v&K&&(A=A.add(I)),I=I.double(),$>>=K,v>>=K;return _&&(E=E.negate()),O&&(A=A.negate()),A=new h(n.mul(A.px,x.beta),A.py,A.pz),E.add(A)}multiply(l){const{endo:g,n:x}=e;lt("scalar",l,K,x);let _,$;if(g){const{k1neg:O,k1:v,k2neg:E,k2:A}=g.splitScalar(l);let{p:I,f:z}=this.wNAF(v),{p:T,f:U}=this.wNAF(A);I=B.constTimeNegate(O,I),T=B.constTimeNegate(E,T),T=new h(n.mul(T.px,g.beta),T.py,T.pz),_=I.add(T),$=z.add(U)}else{const{p:O,f:v}=this.wNAF(l);_=O,$=v}return h.normalizeZ([_,$])[0]}multiplyAndAddUnsafe(l,g,x){const _=h.BASE,$=(v,E)=>E===tt||E===K||!v.equals(_)?v.multiplyUnsafe(E):v.multiply(E),O=$(this,g).add($(l,x));return O.is0()?void 0:O}toAffine(l){return u(this,l)}isTorsionFree(){const{h:l,isTorsionFree:g}=e;if(l===K)return!0;if(g)return g(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=e;return l===K?this:g?g(h,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return Bt("isCompressed",l),this.assertValidity(),i(h,this,l)}toHex(l=!0){return Bt("isCompressed",l),At(this.toRawBytes(l))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const p=e.nBitLength,B=er(h,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:o,weierstrassEquation:f,isWithinCurveOrder:c}}function cr(t){const e=Ge(t);return Tt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function fr(t){const e=cr(t),{Fp:n,n:r}=e,i=n.BYTES+1,s=2*n.BYTES+1;function f(y){return V(y,r)}function c(y){return Jt(y,r)}const{ProjectivePoint:o,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:d}=sr({...e,toBytes(y,b,m){const S=b.toAffine(),L=n.toBytes(S.x),N=gt;return Bt("isCompressed",m),m?N(Uint8Array.from([b.hasEvenY()?2:3]),L):N(Uint8Array.from([4]),L,n.toBytes(S.y))},fromBytes(y){const b=y.length,m=y[0],S=y.subarray(1);if(b===i&&(m===2||m===3)){const L=nt(S);if(!St(L,K,n.ORDER))throw new Error("Point is not on curve");const N=u(L);let H;try{H=n.sqrt(N)}catch(Y){const rt=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+rt)}const C=(H&K)===K;return(m&1)===1!==C&&(H=n.neg(H)),{x:L,y:H}}else if(b===s&&m===4){const L=n.fromBytes(S.subarray(0,n.BYTES)),N=n.fromBytes(S.subarray(n.BYTES,2*n.BYTES));return{x:L,y:N}}else throw new Error(`Point of length ${b} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)}}),h=y=>At(at(y,e.nByteLength));function p(y){const b=r>>K;return y>b}function B(y){return p(y)?f(-y):y}const w=(y,b,m)=>nt(y.slice(b,m));class l{constructor(b,m,S){this.r=b,this.s=m,this.recovery=S,this.assertValidity()}static fromCompact(b){const m=e.nByteLength;return b=k("compactSignature",b,m*2),new l(w(b,0,m),w(b,m,2*m))}static fromDER(b){const{r:m,s:S}=J.toSig(k("DER",b));return new l(m,S)}assertValidity(){lt("r",this.r,K,r),lt("s",this.s,K,r)}addRecoveryBit(b){return new l(this.r,this.s,b)}recoverPublicKey(b){const{r:m,s:S,recovery:L}=this,N=v(k("msgHash",b));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const H=L===2||L===3?m+e.n:m;if(H>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=L&1?"03":"02",Z=o.fromHex(C+h(H)),Y=c(H),rt=f(-N*Y),It=f(S*Y),ot=o.BASE.multiplyAndAddUnsafe(Z,rt,It);if(!ot)throw new Error("point at infinify");return ot.assertValidity(),ot}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new l(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return vt(this.toDERHex())}toDERHex(){return J.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return vt(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const g={isValidPrivateKey(y){try{return a(y),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const y=Fe(e.n);return Jn(e.randomBytes(y),e.n)},precompute(y=8,b=o.BASE){return b._setWindowSize(y),b.multiply(BigInt(3)),b}};function x(y,b=!0){return o.fromPrivateKey(y).toRawBytes(b)}function _(y){const b=ht(y),m=typeof y=="string",S=(b||m)&&y.length;return b?S===i||S===s:m?S===2*i||S===2*s:y instanceof o}function $(y,b,m=!0){if(_(y))throw new Error("first arg must be private key");if(!_(b))throw new Error("second arg must be public key");return o.fromHex(b).multiply(a(y)).toRawBytes(m)}const O=e.bits2int||function(y){const b=nt(y),m=y.length*8-e.nBitLength;return m>0?b>>BigInt(m):b},v=e.bits2int_modN||function(y){return f(O(y))},E=ae(e.nBitLength);function A(y){return lt(`num < 2^${e.nBitLength}`,y,tt,E),at(y,e.nByteLength)}function I(y,b,m=z){if(["recovered","canonical"].some(ut=>ut in m))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:L}=e;let{lowS:N,prehash:H,extraEntropy:C}=m;N==null&&(N=!0),y=k("msgHash",y),_e(m),H&&(y=k("prehashed msgHash",S(y)));const Z=v(y),Y=a(b),rt=[A(Y),A(Z)];if(C!=null&&C!==!1){const ut=C===!0?L(n.BYTES):C;rt.push(k("extraEntropy",ut))}const It=gt(...rt),ot=Z;function Zt(ut){const wt=O(ut);if(!d(wt))return;const ge=c(wt),yt=o.BASE.multiply(wt).toAffine(),G=f(yt.x);if(G===tt)return;const pt=f(ge*f(ot+G*Y));if(pt===tt)return;let we=(yt.x===G?0:2)|Number(yt.y&K),ye=pt;return N&&p(pt)&&(ye=B(pt),we^=1),new l(G,ye,we)}return{seed:It,k2sig:Zt}}const z={lowS:e.lowS,prehash:!1},T={lowS:e.lowS,prehash:!1};function U(y,b,m=z){const{seed:S,k2sig:L}=I(y,b,m),N=e;return Ve(N.hash.outputLen,N.nByteLength,N.hmac)(S,L)}o.BASE._setWindowSize(8);function R(y,b,m,S=T){var yt;const L=y;if(b=k("msgHash",b),m=k("publicKey",m),"strict"in S)throw new Error("options.strict was renamed to lowS");_e(S);const{lowS:N,prehash:H}=S;let C,Z;try{if(typeof L=="string"||ht(L))try{C=l.fromDER(L)}catch(G){if(!(G instanceof J.Err))throw G;C=l.fromCompact(L)}else if(typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint"){const{r:G,s:pt}=L;C=new l(G,pt)}else throw new Error("PARSE");Z=o.fromHex(m)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&C.hasHighS())return!1;H&&(b=e.hash(b));const{r:Y,s:rt}=C,It=v(b),ot=c(rt),Zt=f(It*ot),ut=f(Y*ot),wt=(yt=o.BASE.multiplyAndAddUnsafe(Z,Zt,ut))==null?void 0:yt.toAffine();return wt?f(wt.x)===Y:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:$,sign:U,verify:R,ProjectivePoint:o,Signature:l,utils:g}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function lr(t){return{hash:t,hmac:(e,...n)=>Ke(t,e,_n(...n)),randomBytes:Ze}}function ar(t,e){const n=r=>fr({...t,...lr(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ot=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ht=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_t=BigInt(1),Ct=BigInt(2),Ue=(t,e)=>(t+e/Ct)/e;function De(t){const e=Ot,n=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),f=BigInt(23),c=BigInt(44),o=BigInt(88),a=t*t*t%e,u=a*a*t%e,d=F(u,n,e)*u%e,h=F(d,n,e)*u%e,p=F(h,Ct,e)*a%e,B=F(p,i,e)*p%e,w=F(B,s,e)*B%e,l=F(w,c,e)*w%e,g=F(l,o,e)*l%e,x=F(g,c,e)*w%e,_=F(x,n,e)*u%e,$=F(_,f,e)*B%e,O=F($,r,e)*a%e,v=F(O,Ct,e);if(!te.eql(te.sqr(v),t))throw new Error("Cannot find square root");return v}const te=Me(Ot,void 0,void 0,{sqrt:De}),ue=ar({a:BigInt(0),b:BigInt(7),Fp:te,n:Ht,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ht,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_t*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),c=Ue(s*t,e),o=Ue(-r*t,e);let a=V(t-c*n-o*i,e),u=V(-c*r-o*s,e);const d=a>f,h=u>f;if(d&&(a=e-a),h&&(u=e-u),a>f||u>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:d,k1:a,k2neg:h,k2:u}}}},Wt),We=BigInt(0),Le={};function Rt(t,...e){let n=Le[t];if(n===void 0){const r=Wt(Uint8Array.from(t,i=>i.charCodeAt(0)));n=gt(r,r),Le[t]=n}return Wt(gt(n,...e))}const de=t=>t.toRawBytes(!0).slice(1),ee=t=>at(t,32),Ft=t=>V(t,Ot),$t=t=>V(t,Ht),he=ue.ProjectivePoint,ur=(t,e,n)=>he.BASE.multiplyAndAddUnsafe(t,e,n);function ne(t){let e=ue.utils.normPrivateKeyToScalar(t),n=he.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:$t(-e),bytes:de(n)}}function Xe(t){lt("x",t,_t,Ot);const e=Ft(t*t),n=Ft(e*t+BigInt(7));let r=De(n);r%Ct!==We&&(r=Ft(-r));const i=new he(t,r,_t);return i.assertValidity(),i}const Et=nt;function Qe(...t){return $t(Et(Rt("BIP0340/challenge",...t)))}function dr(t){return ne(t).bytes}function hr(t,e,n=Ze(32)){const r=k("message",t),{bytes:i,scalar:s}=ne(e),f=k("auxRand",n,32),c=ee(s^Et(Rt("BIP0340/aux",f))),o=Rt("BIP0340/nonce",c,i,r),a=$t(Et(o));if(a===We)throw new Error("sign failed: k is zero");const{bytes:u,scalar:d}=ne(a),h=Qe(u,i,r),p=new Uint8Array(64);if(p.set(u,0),p.set(ee($t(d+h*s)),32),!Je(p,r,i))throw new Error("sign: Invalid signature produced");return p}function Je(t,e,n){const r=k("signature",t,64),i=k("message",e),s=k("publicKey",n,32);try{const f=Xe(Et(s)),c=Et(r.subarray(0,32));if(!St(c,_t,Ot))return!1;const o=Et(r.subarray(32,64));if(!St(o,_t,Ht))return!1;const a=Qe(ee(c),de(f),i),u=ur(f,o,$t(-a));return!(!u||!u.hasEvenY()||u.toAffine().x!==c)}catch{return!1}}const xr={getPublicKey:dr,sign:hr,verify:Je,utils:{randomPrivateKey:ue.utils.randomPrivateKey,lift_x:Xe,pointToBytes:de,numberToBytesBE:at,bytesToNumberBE:nt,taggedHash:Rt,mod:V}};export{xr as a,pr as b,wr as c,yr as d,gr as e,br as h,Wt as s};
